grid <- grid %>% add_predictions(mod) # Uses x values in grid and makes prediction, pred
grid
# now plot these
ggplot(sim1, aes(x, y)) +
geom_point() +
geom_line(aes(x, pred), data = grid, color = 'red') +
geom_point(aes(x, pred), data = grid, color = 'red')
# To visualize the residuals, we want to add them to our data frame
sim1resid <- sim1 %>% add_residuals(mod); sim1resid
# Do they have a particular pattern to their distribution? Plot the distribution of the residuals
sim1resid %>%
ggplot(aes(x, y = resid)) +
geom_point() +
geom_ref_line(h = 0) # the mean residual value associated with a least squares line is 0
sim1resid %>%
ggplot(aes(x = resid)) +
geom_histogram(binwidth = 0.25)
sim1resid %>%
ggplot(aes(x = resid)) +
geom_freqpoly(binwidth = 0.25)
sim1resid %>%
ggplot(aes(x = resid)) +
geom_density()
# look at sim2
sim2
# x is NOT numberical, it's categorical
# we can still do a linear model:
# what does y ~ x mean when x is categorical
model_matrix(y ~ x, data = sim2)
# coefficients are intercept, xb, xc, xd
# y = a1 + a2 * xb + a3 * xc + a4 * xd -> so four coefficients
# The intercept gives the value associated with x = a,
# a2 gives the values associated with x = b, a3 with x = c, and a4 with x = d
# when xb = 0, xc = 0, xd = 0 ---> think of 0's and 1's as FALSE and TRUE
# find the model
mod <- lm(y ~ x, data = sim2)
(coe <- coefficients(mod))
# let's plot our data and then add the linear model
ggplot(sim2, aes(x)) +
geom_point(aes(y = y))
grid <- (data_grid(sim2, x) %>%
add_predictions(mod))
grid
ggplot(sim2, aes(x)) +
geom_point(aes(y = y)) +
geom_point(aes(x, pred), data = grid, color = 'red')
sim2 %>%
group_by(x) %>%
summarise(mu = mean(y))
coe
# mean for x = a
coe[[1]]
# mean for x = b
coe[[1]] + coe[[2]]
# mean for x = c
coe[[1]] + coe[[3]]
# mean for x = d
coe[[1]] + coe[[4]]
# Let's look at matrix model for y ~ x - 1
model_matrix(y ~ x - 1, data = sim2)
mod2 <- lm(y ~ x - 1, data = sim2)
coefficients(mod2)
# corresponds to model:
# y = a1 * xa + a2 * xb + a3 * xc + a4 * xd
sim2resid <- sim2 %>% add_residuals(mod)
sim2resid2 <- sim2 %>% add_residuals(mod2)
# plot residuals
sim2resid %>%
ggplot(aes(x = resid)) +
geom_histogram(binwidth = 0.25)
sim2resid2 %>%
ggplot(aes(x = resid)) +
geom_histogram(binwidth = 0.25)
sim2resid %>%
ggplot(aes(x, y = resid)) +
geom_point() +
geom_ref_line(h = 0)
sim3
# use two inputs: x1 (numerical), x2 (categorical)
# can you guess the number of coefficients for y ~ x1 + x2
model_matrix(y ~ x1 + x2, data = sim3)
# model_matrix(y ~ x1 + x2 - 1, data = sim3)
# We'll also consider another model y ~ x1 * x2
model_matrix(y ~ x1 * x2, data = sim3)
sim3
# use two inputs: x1 (numerical), x2 (categorical)
# can you guess the number of coefficients for y ~ x1 + x2
model_matrix(y ~ x1 + x2, data = sim3)
# model_matrix(y ~ x1 + x2 - 1, data = sim3)
# We'll also consider another model y ~ x1 * x2
model_matrix(y ~ x1 * x2, data = sim3)
# Find these two models
mod1 <- lm(y ~ x1 + x2, data = sim3)
mod2 <- lm(y ~ x1 * x2, data = sim3)
sim3
# use two inputs: x1 (numerical), x2 (categorical)
# can you guess the number of coefficients for y ~ x1 + x2
model_matrix(y ~ x1 + x2, data = sim3)
# model_matrix(y ~ x1 + x2 - 1, data = sim3)
# We'll also consider another model y ~ x1 * x2
model_matrix(y ~ x1 * x2, data = sim3)
# Find these two models
mod1 <- lm(y ~ x1 + x2, data = sim3)
mod2 <- lm(y ~ x1 * x2, data = sim3)
coe1 <- coefficients(mod1)
coe2 <- coefficients(mod2)
sim3
# use two inputs: x1 (numerical), x2 (categorical)
# can you guess the number of coefficients for y ~ x1 + x2
model_matrix(y ~ x1 + x2, data = sim3)
# model_matrix(y ~ x1 + x2 - 1, data = sim3)
# We'll also consider another model y ~ x1 * x2
model_matrix(y ~ x1 * x2, data = sim3)
# Find these two models
mod1 <- lm(y ~ x1 + x2, data = sim3)
mod2 <- lm(y ~ x1 * x2, data = sim3)
coe1 <- coefficients(mod1); coe1
coe2 <- coefficients(mod2); coe2
sim3
# use two inputs: x1 (numerical), x2 (categorical)
# can you guess the number of coefficients for y ~ x1 + x2
model_matrix(y ~ x1 + x2, data = sim3)
# model_matrix(y ~ x1 + x2 - 1, data = sim3)
# We'll also consider another model y ~ x1 * x2
model_matrix(y ~ x1 * x2, data = sim3)
# Find these two models
mod1 <- lm(y ~ x1 + x2, data = sim3)
mod2 <- lm(y ~ x1 * x2, data = sim3)
coe1 <- coefficients(mod1); coe1
coe2 <- coefficients(mod2); coe2
# Look at the fit with the predicitons of the model:
# 1) Make a grid of my domain with equally spaced values.
#    Domain is 2 dimensional.
grid <- data_grid(data = sim3, x1, x2)
sim3
# use two inputs: x1 (numerical), x2 (categorical)
# can you guess the number of coefficients for y ~ x1 + x2
model_matrix(y ~ x1 + x2, data = sim3)
# model_matrix(y ~ x1 + x2 - 1, data = sim3)
# We'll also consider another model y ~ x1 * x2
model_matrix(y ~ x1 * x2, data = sim3)
# Find these two models
mod1 <- lm(y ~ x1 + x2, data = sim3)
mod2 <- lm(y ~ x1 * x2, data = sim3)
coe1 <- coefficients(mod1); coe1
coe2 <- coefficients(mod2); coe2
# Look at the fit with the predicitons of the model:
# 1) Make a grid of my domain with equally spaced values.
#    Domain is 2 dimensional.
grid <- data_grid(data = sim3, x1, x2); grid
?add_predictions
sim3
# use two inputs: x1 (numerical), x2 (categorical)
# can you guess the number of coefficients for y ~ x1 + x2
model_matrix(y ~ x1 + x2, data = sim3)
# model_matrix(y ~ x1 + x2 - 1, data = sim3)
# We'll also consider another model y ~ x1 * x2
model_matrix(y ~ x1 * x2, data = sim3)
# Find these two models
mod1 <- lm(y ~ x1 + x2, data = sim3)
mod2 <- lm(y ~ x1 * x2, data = sim3)
coe1 <- coefficients(mod1); coe1
coe2 <- coefficients(mod2); coe2
# Look at the fit with the predictions of the model:
# 1) Make a grid of my domain with equally spaced values.
#    Domain is 2 dimensional.
grid <- data_grid(data = sim3, x1, x2); grid
# 2) Get the associated predictions for those values and add as columns in our grid.
#    ?add_predictions
grid <- (grid %>%
spread_predictions(mod1, mod2))
sim3
# use two inputs: x1 (numerical), x2 (categorical)
# can you guess the number of coefficients for y ~ x1 + x2
model_matrix(y ~ x1 + x2, data = sim3)
# model_matrix(y ~ x1 + x2 - 1, data = sim3)
# We'll also consider another model y ~ x1 * x2
model_matrix(y ~ x1 * x2, data = sim3)
# Find these two models
mod1 <- lm(y ~ x1 + x2, data = sim3)
mod2 <- lm(y ~ x1 * x2, data = sim3)
coe1 <- coefficients(mod1); coe1
coe2 <- coefficients(mod2); coe2
# Look at the fit with the predictions of the model:
# 1) Make a grid of my domain with equally spaced values.
#    Domain is 2 dimensional.
grid <- data_grid(data = sim3, x1, x2); grid
# 2) Get the associated predictions for those values and add as columns in our grid.
#    ?add_predictions
grid <- (grid %>%
spread_predictions(mod1, mod2))
grid
# Plot our prediction (careful, in 3D, let's use x = x1, y = y or pred, color = x2)
ggplot(sim3, aex(x1)) +
geom_point(aex(y, color = x2))
sim3
# use two inputs: x1 (numerical), x2 (categorical)
# can you guess the number of coefficients for y ~ x1 + x2
model_matrix(y ~ x1 + x2, data = sim3)
# model_matrix(y ~ x1 + x2 - 1, data = sim3)
# We'll also consider another model y ~ x1 * x2
model_matrix(y ~ x1 * x2, data = sim3)
# Find these two models
mod1 <- lm(y ~ x1 + x2, data = sim3)
mod2 <- lm(y ~ x1 * x2, data = sim3)
coe1 <- coefficients(mod1); coe1
coe2 <- coefficients(mod2); coe2
# Look at the fit with the predictions of the model:
# 1) Make a grid of my domain with equally spaced values.
#    Domain is 2 dimensional.
grid <- data_grid(data = sim3, x1, x2); grid
# 2) Get the associated predictions for those values and add as columns in our grid.
#    ?add_predictions
grid <- (grid %>%
spread_predictions(mod1, mod2))
grid
# Plot our prediction (careful, in 3D, let's use x = x1, y = y or pred, color = x2)
ggplot(sim3, aes(x1)) +
geom_point(aes(y, color = x2))
sim3
# use two inputs: x1 (numerical), x2 (categorical)
# can you guess the number of coefficients for y ~ x1 + x2
model_matrix(y ~ x1 + x2, data = sim3)
# model_matrix(y ~ x1 + x2 - 1, data = sim3)
# We'll also consider another model y ~ x1 * x2
model_matrix(y ~ x1 * x2, data = sim3)
# Find these two models
mod1 <- lm(y ~ x1 + x2, data = sim3)
mod2 <- lm(y ~ x1 * x2, data = sim3)
coe1 <- coefficients(mod1); coe1
coe2 <- coefficients(mod2); coe2
# Look at the fit with the predictions of the model:
# 1) Make a grid of my domain with equally spaced values.
#    Domain is 2 dimensional.
grid <- data_grid(data = sim3, x1, x2); grid
# 2) Get the associated predictions for those values and add as columns in our grid.
#    ?add_predictions
grid <- (grid %>%
spread_predictions(mod1, mod2))
grid
# Plot our prediction (careful, in 3D, let's use x = x1, y = y or pred, color = x2)
ggplot(sim3, aes(x1)) +
geom_point(aes(y = y, color = x2))
sim3
# use two inputs: x1 (numerical), x2 (categorical)
# can you guess the number of coefficients for y ~ x1 + x2
model_matrix(y ~ x1 + x2, data = sim3)
# model_matrix(y ~ x1 + x2 - 1, data = sim3)
# We'll also consider another model y ~ x1 * x2
model_matrix(y ~ x1 * x2, data = sim3)
# Find these two models
mod1 <- lm(y ~ x1 + x2, data = sim3)
mod2 <- lm(y ~ x1 * x2, data = sim3)
coe1 <- coefficients(mod1); coe1
coe2 <- coefficients(mod2); coe2
# Look at the fit with the predictions of the model:
# 1) Make a grid of my domain with equally spaced values.
#    Domain is 2 dimensional.
grid <- data_grid(data = sim3, x1, x2); grid
# 2) Get the associated predictions for those values and add as columns in our grid.
#    ?add_predictions
grid <- (grid %>%
spread_predictions(mod1, mod2))
grid
# Plot our prediction (careful, in 3D, let's use x = x1, y = y or pred, color = x2)
ggplot(sim3, aes(x1)) +
geom_point(aes(y = y, color = x2, size = x2, alpha = 0.5))
# Plot our prediction (careful, in 3D, let's use x = x1, y = y or pred, color = x2)
ggplot(sim3, aes(x1)) +
geom_point(aes(y = y, color = x2, alpha = 0.5))
sim3
# use two inputs: x1 (numerical), x2 (categorical)
# can you guess the number of coefficients for y ~ x1 + x2
model_matrix(y ~ x1 + x2, data = sim3)
# model_matrix(y ~ x1 + x2 - 1, data = sim3)
# We'll also consider another model y ~ x1 * x2
model_matrix(y ~ x1 * x2, data = sim3)
# Find these two models
mod1 <- lm(y ~ x1 + x2, data = sim3)
mod2 <- lm(y ~ x1 * x2, data = sim3)
coe1 <- coefficients(mod1); coe1
coe2 <- coefficients(mod2); coe2
# Look at the fit with the predictions of the model:
# 1) Make a grid of my domain with equally spaced values.
#    Domain is 2 dimensional.
grid <- data_grid(data = sim3, x1, x2); grid
# 2) Get the associated predictions for those values and add as columns in our grid.
#    ?add_predictions
grid <- (grid %>%
spread_predictions(mod1, mod2))
grid
# Plot our prediction (careful, in 3D, let's use x = x1, y = y or pred, color = x2)
ggplot(sim3, aes(x1)) +
geom_point(aes(y = y, color = x2))
sim3
# use two inputs: x1 (numerical), x2 (categorical)
# can you guess the number of coefficients for y ~ x1 + x2
model_matrix(y ~ x1 + x2, data = sim3)
# model_matrix(y ~ x1 + x2 - 1, data = sim3)
# We'll also consider another model y ~ x1 * x2
model_matrix(y ~ x1 * x2, data = sim3)
# Find these two models
mod1 <- lm(y ~ x1 + x2, data = sim3)
mod2 <- lm(y ~ x1 * x2, data = sim3)
coe1 <- coefficients(mod1); coe1
coe2 <- coefficients(mod2); coe2
# Look at the fit with the predictions of the model:
# 1) Make a grid of my domain with equally spaced values.
#    Domain is 2 dimensional.
grid <- data_grid(data = sim3, x1, x2); grid
# 2) Get the associated predictions for those values and add as columns in our grid.
#    ?add_predictions
grid <- (grid %>%
spread_predictions(mod1, mod2))
grid
# Need to pivot_longer so model is a variable and we can use it as a dimension
grid_longer <- grid %>% pivot_longer(mod1:mod2, names_to = "model", values_to = "pred")
# Plot our prediction (careful, in 3D, let's use x = x1, y = y or pred, color = x2)
ggplot(sim3, aes(x1)) +
geom_point(aes(y = y, color = x2)) +
geom_point(aes(x, y = pred))
# Need to pivot_longer so model is a variable and we can use it as a dimension
grid_longer <- grid %>% pivot_longer(mod1:mod2, names_to = "model", values_to = "pred"); grid_longer
sim3
# use two inputs: x1 (numerical), x2 (categorical)
# can you guess the number of coefficients for y ~ x1 + x2
model_matrix(y ~ x1 + x2, data = sim3)
# model_matrix(y ~ x1 + x2 - 1, data = sim3)
# We'll also consider another model y ~ x1 * x2
model_matrix(y ~ x1 * x2, data = sim3)
# Find these two models
mod1 <- lm(y ~ x1 + x2, data = sim3)
mod2 <- lm(y ~ x1 * x2, data = sim3)
coe1 <- coefficients(mod1); coe1
coe2 <- coefficients(mod2); coe2
# Look at the fit with the predictions of the model:
# 1) Make a grid of my domain with equally spaced values.
#    Domain is 2 dimensional.
grid <- data_grid(data = sim3, x1, x2); grid
# 2) Get the associated predictions for those values and add as columns in our grid.
#    ?add_predictions
grid <- (grid %>%
spread_predictions(mod1, mod2))
grid
# Need to pivot_longer so model is a variable and we can use it as a dimension
grid_longer <- grid %>% pivot_longer(mod1:mod2, names_to = "model", values_to = "pred"); grid_longer
# Plot our prediction (careful, in 3D, let's use x = x1, y = y or pred, color = x2)
ggplot(sim3, aes(x1)) +
geom_point(aes(y = y, color = x2)) +
geom_point(aes(x1, y = pred, col = x2), grid_longer) +
facet_wrap(~ model)
sim3
# use two inputs: x1 (numerical), x2 (categorical)
# can you guess the number of coefficients for y ~ x1 + x2
model_matrix(y ~ x1 + x2, data = sim3)
# model_matrix(y ~ x1 + x2 - 1, data = sim3)
# We'll also consider another model y ~ x1 * x2
model_matrix(y ~ x1 * x2, data = sim3)
# Find these two models
mod1 <- lm(y ~ x1 + x2, data = sim3)
mod2 <- lm(y ~ x1 * x2, data = sim3)
coe1 <- coefficients(mod1); coe1
coe2 <- coefficients(mod2); coe2
# Look at the fit with the predictions of the model:
# 1) Make a grid of my domain with equally spaced values.
#    Domain is 2 dimensional.
grid <- data_grid(data = sim3, x1, x2); grid
# 2) Get the associated predictions for those values and add as columns in our grid.
#    ?add_predictions
grid <- (grid %>%
spread_predictions(mod1, mod2))
grid
# Need to pivot_longer so model is a variable and we can use it as a dimension
grid_longer <- grid %>% pivot_longer(mod1:mod2, names_to = "model", values_to = "pred"); grid_longer
# Plot our prediction (careful, in 3D, let's use x = x1, y = y or pred, color = x2)
ggplot(sim3, aes(x1)) +
geom_point(aes(y = y, color = x2)) +
geom_point(aes(x1, y = pred, col = x2, shape = x2), grid_longer) +
facet_wrap(~ model)
sim3
# use two inputs: x1 (numerical), x2 (categorical)
# can you guess the number of coefficients for y ~ x1 + x2
model_matrix(y ~ x1 + x2, data = sim3)
# model_matrix(y ~ x1 + x2 - 1, data = sim3)
# We'll also consider another model y ~ x1 * x2
model_matrix(y ~ x1 * x2, data = sim3)
# Find these two models
mod1 <- lm(y ~ x1 + x2, data = sim3)
mod2 <- lm(y ~ x1 * x2, data = sim3)
coe1 <- coefficients(mod1); coe1
coe2 <- coefficients(mod2); coe2
# Look at the fit with the predictions of the model:
# 1) Make a grid of my domain with equally spaced values.
#    Domain is 2 dimensional.
grid <- data_grid(data = sim3, x1, x2); grid
# 2) Get the associated predictions for those values and add as columns in our grid.
#    ?add_predictions
grid <- (grid %>%
spread_predictions(mod1, mod2))
grid
# Need to pivot_longer so model is a variable and we can use it as a dimension
grid_longer <- grid %>% pivot_longer(mod1:mod2, names_to = "model", values_to = "pred"); grid_longer
# Plot our prediction (careful, in 3D, let's use x = x1, y = y or pred, color = x2)
ggplot(sim3, aes(x1)) +
geom_point(aes(y = y, color = x2)) +
geom_line(aes(x1, y = pred, col = x2), grid_longer) +
facet_wrap(~ model)
sim3
# use two inputs: x1 (numerical), x2 (categorical)
# can you guess the number of coefficients for y ~ x1 + x2
model_matrix(y ~ x1 + x2, data = sim3)
# model_matrix(y ~ x1 + x2 - 1, data = sim3)
# We'll also consider another model y ~ x1 * x2
model_matrix(y ~ x1 * x2, data = sim3)
# Find these two models
mod1 <- lm(y ~ x1 + x2, data = sim3)
mod2 <- lm(y ~ x1 * x2, data = sim3)
coe1 <- coefficients(mod1); coe1
coe2 <- coefficients(mod2); coe2
# Look at the fit with the predictions of the model:
# 1) Make a grid of my domain with equally spaced values.
#    Domain is 2 dimensional.
grid <- data_grid(data = sim3, x1, x2); grid
# 2) Get the associated predictions for those values and add as columns in our grid.
#    ?add_predictions
grid <- (grid %>%
spread_predictions(mod1, mod2))
grid
# Need to pivot_longer so model is a variable and we can use it as a dimension
grid_longer <- grid %>% pivot_longer(mod1:mod2, names_to = "model", values_to = "pred"); grid_longer
# Plot our prediction (careful, in 3D, let's use x = x1, y = y or pred, color = x2)
ggplot(sim3, aes(x1)) +
geom_point(aes(y = y, color = x2)) +
geom_line(aes(x1, y = pred, col = x2), grid_longer) +
facet_wrap(~ model)
# Hard to tell where model is,
# Another possible visualization:
# Equivalent to spread_predictions + pivot_longer is gather_predictions
grid <- data_grid(data = sim3, x1, x2); grid
grid <- grid %>% gather_predictions(mod1, mod2); grid
sim3
# use two inputs: x1 (numerical), x2 (categorical)
# can you guess the number of coefficients for y ~ x1 + x2
model_matrix(y ~ x1 + x2, data = sim3)
# model_matrix(y ~ x1 + x2 - 1, data = sim3)
# We'll also consider another model y ~ x1 * x2
model_matrix(y ~ x1 * x2, data = sim3)
# Find these two models
mod1 <- lm(y ~ x1 + x2, data = sim3)
mod2 <- lm(y ~ x1 * x2, data = sim3)
coe1 <- coefficients(mod1); coe1
coe2 <- coefficients(mod2); coe2
# Look at the fit with the predictions of the model:
# 1) Make a grid of my domain with equally spaced values.
#    Domain is 2 dimensional.
grid <- data_grid(data = sim3, x1, x2); grid
# 2) Get the associated predictions for those values and add as columns in our grid.
#    ?add_predictions
grid <- (grid %>%
spread_predictions(mod1, mod2))
grid
# Need to pivot_longer so model is a variable and we can use it as a dimension
grid_longer <- grid %>% pivot_longer(mod1:mod2, names_to = "model", values_to = "pred"); grid_longer
# Plot our prediction (careful, in 3D, let's use x = x1, y = y or pred, color = x2)
ggplot(sim3, aes(x1)) +
geom_point(aes(y = y, color = x2)) +
geom_line(aes(x1, y = pred, col = x2), grid_longer) +
facet_wrap(~ model)
# Hard to tell where model is,
# Another possible visualization:
# Equivalent to spread_predictions + pivot_longer is gather_predictions
grid <- data_grid(data = sim3, x1, x2); grid
grid <- grid %>% gather_predictions(mod1, mod2); grid
sim3resid <- sim3 %>% gather_residuals(mod1, mod2)
sim3
# use two inputs: x1 (numerical), x2 (categorical)
# can you guess the number of coefficients for y ~ x1 + x2
model_matrix(y ~ x1 + x2, data = sim3)
# model_matrix(y ~ x1 + x2 - 1, data = sim3)
# We'll also consider another model y ~ x1 * x2
model_matrix(y ~ x1 * x2, data = sim3)
# Find these two models
mod1 <- lm(y ~ x1 + x2, data = sim3)
mod2 <- lm(y ~ x1 * x2, data = sim3)
coe1 <- coefficients(mod1); coe1
coe2 <- coefficients(mod2); coe2
# Look at the fit with the predictions of the model:
# 1) Make a grid of my domain with equally spaced values.
#    Domain is 2 dimensional.
grid <- data_grid(data = sim3, x1, x2); grid
# 2) Get the associated predictions for those values and add as columns in our grid.
#    ?add_predictions
grid <- (grid %>%
spread_predictions(mod1, mod2))
grid
# Need to pivot_longer so model is a variable and we can use it as a dimension
grid_longer <- grid %>% pivot_longer(mod1:mod2, names_to = "model", values_to = "pred"); grid_longer
# Plot our prediction (careful, in 3D, let's use x = x1, y = y or pred, color = x2)
ggplot(sim3, aes(x1)) +
geom_point(aes(y = y, color = x2)) +
geom_line(aes(x1, y = pred, col = x2), grid_longer) +
facet_wrap(~ model)
# Hard to tell where model is,
# Another possible visualization:
# Equivalent to spread_predictions + pivot_longer is gather_predictions
grid <- data_grid(data = sim3, x1, x2); grid
grid <- grid %>% gather_predictions(mod1, mod2); grid
sim3resid <- sim3 %>% gather_residuals(mod1, mod2)
sim3resid %>%
ggplot(aes(x = x1, y = resid, col = x2)) +
geom_point() +
facet_grid(model ~ x2)
